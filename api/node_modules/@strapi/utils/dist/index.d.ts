/// <reference types="koa" />
/// <reference types="formidable" />
/// <reference types="lodash" />
/**
 * Export shared utilities
 */
import parseMultipartData from './parse-multipart';
import parseType from './parse-type';
import * as policy from './policy';
import templateConfiguration from './template-configuration';
import { yup, handleYupError, validateYupSchema, validateYupSchemaSync } from './validators';
import * as errors from './errors';
import { nameToSlug, nameToCollectionName, getCommonBeginning, escapeQuery, stringIncludes, stringEquals, isKebabCase, isCamelCase, toRegressedEnumValue, startsWithANumber, joinBy, toKebabCase } from './string-formatting';
import { removeUndefined, keysDeep } from './object-formatting';
import { getConfigUrls, getAbsoluteAdminUrl, getAbsoluteServerUrl } from './config';
import { generateTimestampCode } from './code-generator';
import * as contentTypes from './content-types';
import env from './env-helper';
import * as relations from './relations';
import setCreatorFields from './set-creator-fields';
import * as hooks from './hooks';
import providerFactory from './provider-factory';
import * as pagination from './pagination';
import sanitize from './sanitize';
import traverseEntity from './traverse-entity';
import { pipeAsync, mapAsync, reduceAsync, forEachAsync } from './async';
import convertQueryParams from './convert-query-params';
import importDefault from './import-default';
import * as template from './template';
import * as file from './file';
import * as traverse from './traverse';
export { yup, handleYupError, policy, templateConfiguration, parseMultipartData, sanitize, traverseEntity, parseType, nameToSlug, toRegressedEnumValue, startsWithANumber, joinBy, nameToCollectionName, getCommonBeginning, getConfigUrls, escapeQuery, removeUndefined, keysDeep, getAbsoluteAdminUrl, getAbsoluteServerUrl, generateTimestampCode, stringIncludes, stringEquals, template, isKebabCase, isCamelCase, toKebabCase, contentTypes, env, relations, setCreatorFields, hooks, providerFactory, pagination, pipeAsync, mapAsync, reduceAsync, forEachAsync, errors, validateYupSchema, validateYupSchemaSync, convertQueryParams, importDefault, file, traverse, };
declare const utils: {
    yup: typeof import("yup") & {
        strapiID: () => import("./validators").StrapiIDSchema;
    };
    handleYupError: (error: import("yup").ValidationError, errorMessage: string) => never;
    policy: typeof policy;
    templateConfiguration: (obj: Record<string, any>, configPath?: string) => Record<string, any>;
    parseMultipartData: (ctx: import("./types").Context) => import("koa").Context | {
        data: any;
        files: import("formidable").Files;
    };
    sanitize: {
        contentAPI: {
            input: import("./sanitize").SanitizeFunc;
            output: import("./sanitize").SanitizeFunc;
            query: (query: Record<string, unknown>, schema: import("./types").Model, { auth }?: import("./sanitize").Options) => Promise<Record<string, unknown>>;
            filters: import("./sanitize").SanitizeFunc;
            sort: import("./sanitize").SanitizeFunc;
            fields: import("./sanitize").SanitizeFunc;
            populate: import("./sanitize").SanitizeFunc;
        };
        sanitizers: typeof import("./sanitize/sanitizers");
        visitors: typeof import("./sanitize/visitors");
    };
    traverseEntity: import("lodash").CurriedFunction3<import("./traverse-entity").Visitor, import("./traverse-entity").TraverseOptions, import("./traverse-entity").Data, Promise<import("./traverse-entity").Data>>;
    parseType: (options: import("./parse-type").ParseTypeOptions) => any;
    nameToSlug: (name: string, options?: {
        separator: string;
    }) => string;
    toRegressedEnumValue: (value: string) => string;
    startsWithANumber: (value: string) => boolean;
    joinBy: (joint: string, ...args: string[]) => string;
    nameToCollectionName: (name: string) => string;
    getCommonBeginning: (...strings: string[]) => string;
    getConfigUrls: (config: import("./types").Config, forAdminBuild?: boolean) => {
        serverUrl: string;
        adminUrl: any;
        adminPath: any;
    };
    escapeQuery: (query: string, charsToEscape: string, escapeChar?: string) => string;
    removeUndefined: (obj: object) => object;
    keysDeep: (obj: object, path?: string[]) => string[];
    getAbsoluteAdminUrl: (config: import("./types").Config, forAdminBuild?: boolean) => any;
    getAbsoluteServerUrl: (config: import("./types").Config, forAdminBuild?: boolean) => any;
    generateTimestampCode: (date: Date) => string;
    stringIncludes: (arr: unknown[], val: unknown) => boolean;
    stringEquals: (a: unknown, b: unknown) => boolean;
    template: typeof template;
    isKebabCase: (value: string) => boolean;
    isCamelCase: (value: string) => boolean;
    toKebabCase: (value: string) => string;
    contentTypes: typeof contentTypes;
    env: (<T>(key: string, defaultValue?: T | undefined) => string | T | undefined) & {
        int(key: string, defaultValue?: number | undefined): number | undefined;
        float(key: string, defaultValue?: number | undefined): number | undefined;
        bool(key: string, defaultValue?: boolean | undefined): boolean | undefined;
        json(key: string, defaultValue?: object | undefined): any;
        array(key: string, defaultValue?: string[] | undefined): string[] | undefined;
        date(key: string, defaultValue?: Date | undefined): Date | undefined;
        oneOf(key: string, expectedValues?: unknown[] | undefined, defaultValue?: unknown): unknown;
    };
    relations: typeof relations;
    setCreatorFields: ({ user, isEdition }: import("./set-creator-fields").Options) => (data: object) => object;
    hooks: typeof hooks;
    providerFactory: (options?: import("./provider-factory").Options) => {
        hooks: {
            willRegister: {
                call(context: unknown): Promise<void>;
                getHandlers(): hooks.Handler[];
                register(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
                delete(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
            };
            didRegister: {
                call(context: unknown): Promise<any[]>;
                getHandlers(): hooks.Handler[];
                register(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
                delete(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
            };
            willDelete: {
                call(context: unknown): Promise<any[]>;
                getHandlers(): hooks.Handler[];
                register(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
                delete(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
            };
            didDelete: {
                call(context: unknown): Promise<any[]>;
                getHandlers(): hooks.Handler[];
                register(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
                delete(handler: hooks.Handler): {
                    getHandlers(): hooks.Handler[];
                    register(handler: hooks.Handler): any;
                    delete(handler: hooks.Handler): any;
                    call(): never;
                };
            };
        };
        register(key: string, item: unknown): Promise<any>;
        delete(key: string): Promise<any>;
        get(key: string): any;
        getWhere(filters?: {}): any[];
        values(): any[];
        keys(): any[];
        has(key: string): boolean;
        size(): number;
        clear(): Promise<any>;
    };
    pagination: typeof pagination;
    pipeAsync: typeof pipeAsync;
    mapAsync: (...args: any[]) => any;
    reduceAsync: (mixedArray: any[]) => <T_1>(iteratee: (...args: any) => any, initialValue?: T_1 | undefined) => Promise<T_1 | undefined>;
    forEachAsync: <T_2, R>(array: T_2[], func: import("p-map").Mapper<T_2, R>, options: import("p-map").Options) => Promise<void>;
    errors: typeof errors;
    validateYupSchema: (schema: import("yup").AnySchema, options?: {}) => (body: unknown, errorMessage: string) => Promise<any>;
    validateYupSchemaSync: (schema: import("yup").AnySchema, options?: {}) => (body: unknown, errorMessage: string) => any;
    convertQueryParams: {
        convertSortQueryParams: (sortQuery: string | object | string[]) => import("./convert-query-params").SortMap | import("./convert-query-params").SortMap[];
        convertStartQueryParams: (startQuery: unknown) => number;
        convertLimitQueryParams: (limitQuery: unknown) => number | undefined;
        convertPopulateQueryParams: (populate: string | string[] | import("./convert-query-params").PopulateAttributesParams, schema: import("./types").Model, depth?: number) => boolean | string[] | {
            [key: string]: boolean | string[] | any;
        };
        convertFiltersQueryParams: (filters: unknown, schema: import("./types").Model) => import("./convert-query-params").WhereQuery;
        convertFieldsQueryParams: (fields: string | string[], depth?: number) => (string | string[]) | undefined;
        convertPublicationStateParams: (schema: import("./types").Model, params?: {
            publicationState?: "live" | "preview" | undefined;
        }, query?: import("./convert-query-params").Query) => void;
        transformParamsToQuery: (uid: string, params: import("./convert-query-params").Params) => import("./convert-query-params").Query;
    };
    importDefault: typeof importDefault;
    file: typeof file;
    traverse: typeof traverse;
};
export default utils;
